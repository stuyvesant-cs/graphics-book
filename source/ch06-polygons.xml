<chapter xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Polygons</title>
  <introduction>
    <p>
      Currently, our basic unit of drawing is a line. When we create a shape, we add edges to an edge matrix, and we loop through that matrix drawing lines. A 3D shape rendered using edges only has no real surface to speak of. Instead, it is a <url href="https://en.wikipedia.org/wiki/Wire-frame_model">wire-frame model</url>. Wire-frame models can be rendered quickly, but because they lack true surface, there are limits to how realistic they can look.
    </p>
    <p>
      If we change our basic unit of drawing form a line to a polygon, we will have surfaces to work with, generating a <url href="https://en.wikipedia.org/wiki/Polygon_mesh">polygon mesh</url>. Having a surface gives us more options when rendering 3D objects. Most notably:
      <ul>
        <li>Polygons can be filled with colors, creating solid objects.</li>
        <li>We can describe polygons as "facing" a particular direction, and use that information to determine sides of our 3D shapes that are facing away from the viewer and should therefore not be rendered.</li>
        <li>We can also use the direction a polygon is facing to help calculate real-world lighting and shading values.</li>
      </ul>
      There are many possible shapes we could use as our basic polygons, we will use triangles, as they are the simplest polygon.
    </p>
  </introduction>
  <section>
    <title>Polygon Lists</title>
    <p>
      Our current shapes are all based on _edge lists_, where every 2 points determine a distinct edge to be drawn. We should keep this framework around in order to draw 2 dimensional shapes when desired. We need to add <em>polygon lists</em>, where every 3 points determine a distinct triangle. Here is a chart comparing the functions in our 2D, edge based, drawing stack and their 3D, polygon based, equivalents.
      <table>
        <tabular>
          <row header="yes">
            <cell>Edge Framework</cell> <cell>Polygon Framework</cell>
          </row>
          <row>
            <cell><line><c>add_point</c></line><line>Add a point to the edge list</line></cell>
            <cell><line><c>add_point</c></line><line>Add a point to the polygon list</line></cell>
          </row>
          <row>
            <cell><line><c>add_edge</c></line><line>Add the endpoints of a line to the edge list.</line></cell>
            <cell><line><c>add_polygon</c></line><line>Add the three vertices of a triangle into the polygon list.</line><line>The vertices must be added in<em>counter-clockwise</em> order.</line></cell>
          </row>
          <row>
            <cell><line><c>draw_lines</c></line><line>Go through the edge list 2 points at a time,</line><line> drawing a line between each pair of points.</line></cell>
            <cell><line><c>draw_polygons</c></line><line>Go through the polygon list 3 points at a time,</line><line> connecting the points to draw a triangle.</line><line>Other polygon features can be added here later.</line></cell>
          </row>
        </tabular>
      </table>
      By adding the points in counter-clockwise order, we will be able to eventually determine what is <em>forwards</em> and <em>backwards</em> with respect to the triangle. This will help us implement more advanced features later.
    </p>
  </section>
  <section>
    <title>Polygon Based Shapes</title>
    <subsection>
      <title>Box</title>
      <p>
        A box has 6 faces, each one made up of 2 triangles. Like before, the easiest thing to do here is add your 12 triangles directly into the polygon list. The order of the triangles does not matter, but <em>the order of the points does</em>. Points should always be added counter-clockwise.
      </p>
    </subsection>

    <subsection>
      <title>Sphere</title>
      <p>
        We generate spheres by drawing a series of rotated semi-circles. If you followed my advice, you should have a separate <c>generate_sphere</c> function that returns a matrix of points for the sphere. Our job now is to go through that list of points, adding triples of points representing the triangles on the surface of the sphere to our polygon list. The best thing to do is physically draw the first two semicircles generated by your code, and write out what triangles are required.
        <image source="images/ch06-sphere_points.png">
          <description>2 sphere semicircles</description>
        </image>
      </p>
      <p>
        When drawing semi-circles, you need to generate the poles, which are created when <c>t=0</c> and <c>t=1</c>, respectively. This is different from drawing full circles, you don't need to include <c>t=1</c> there because the point at <c>t=1</c> is identical to the point at <c>t=0</c>.The way my loops are written, this means when I set <c>steps</c> to 10 I actually get 11 points per semi-circle.
      </p>
      <p>
        It is also important to keep track of the direction your semi-circles are drawn in. If you used the example from class (semi-circles rotated about the x-axis), then each new semi-circle is drawn in front of/below the previous one. Here are some of the triangles taken from the diagram above:
        <cd>
          0: p0, p1, p12
          1: p1, p2, p13
          2: p1, p13, p12
        </cd>
       </p>
       <p>
         At the poles, there is only one triangle to add per section, this is triangle 0 above. Otherwise, triangles are added in pairs, as is shown by triangles 1 and 2. If <c>n</c> is the number of points in a semi-circle, then we can define the triangles for the non-poles as:
         <cd>
           p, p + 1, (p + n) + 1
           p, (p + n) + 1, p + n
         </cd>
         At the poles, we need to make sure not to add both triangles. Following the above formulae, at <c>p=0</c>, we would have triangles <c>0, 1, 12</c> and <c>0, 12, 11</c>. But for the second triangle, <c>0</c> and <c>11</c> are the same point. This would render as a straight line, which might not seem like a big deal, but having these "degenerate" triangles at the poles will cause problems down the line, so it's best to exclude them now.
       </p>
    </subsection>

    <subsection>
      <title>Torus</title>
      <p>
        Torus creation is very similar to the sphere, with a couple of changes.
        <ul>
          <li>Tori must be generated with full circles.</li>
          <li>No 2 circles of a torus share any common points, which means we don't have <em>poles</em>. This actually makes it easier to code since we don't have those special cases.</li>
          <li>The tori from class are generated by rotating about the y-axis. This means that each new circle is drawn <em>behind</em> the previous one.</li>
        </ul>
       As with the sphere, it is advised that you draw out the first two slices of torus to map out the appropriate triangles.
      </p>
    </subsection>
  </section>
  <section>
    <title>Vectors</title>
    <introduction>
      Backface culling is a crucial hidden surface removal algorithm. <em>But</em> before we get into how it works, we need to take a quick detour to cover some pieces of Vector math. This will also come in handy when we start workign with lighting and shading.
    </introduction>
    <p>
      A <url href="https://en.wikipedia.org/wiki/Euclidean_vector">vector</url>is a unit that has both direction and magnitude (size). Vectors are written like so: <m>\lt x, y, z></m> Notice that vector components are placed inside <m>\lt ></m> to differentiate them from points. A point only describes a single point in space, whereas a vector describes a relationship between 2 points (often, not always, an arbitrary point and the origin)
    </p>
    <p>
      You can think of a vector as describing how you would get from point <m>A</m> to point <m>B</m>. For example, consider the following two points:
      <me>
        \begin{aligned}
          p0 \amp= (4, 10, 0) \\
          p1 \amp= (6, 5, 23) \\
        \end{aligned}
      </me>
      To get from <m>p0</m> to <m>p1</m>, you would have to move +2 in x, -5 in y and +23 in z, so we would write the vector as:
      <me>
        \overrightarrow{A} = \lt 2, -5, 23>
      </me>
      The vector from <m>p1</m> to <m>p0</m> moves in the opposite direction, and would be written as:
      <me>
        \overrightarrow{B} = \lt -2, 5, -23>
      </me>

      Generally, you can find the vector between 2 points by subtraction. Notationally, vectors are written with a <m>\rightarrow</m> as seen above.
    </p>
  </section>

</chapter>

<!--
<section>
  <title>Backface Culling</title>
  <introduction>
    As mentioned earlier, Backface Culling is a <em>hidden surface removal</em> algorithm. As the name implies, its purpose is to omit any polygons (or surfaces) that would not be visible normally. Reducind the number of polygons to be rendered will provide a major efficiency boost, especially as we add more complexity (and thus calculations) to our polygon rendering. Backface culling specifically deals with the fact that the back side of a shape is entirely blocked by the front. So at any given viewing angle, you can only see at most half of the 3D shapes we are working with.
  </introduction>
  <p>
    As mentioend before, backface culling is the process of removing the backwards facing surfaces from our rendering engine. In order to do this, we need to define 2 vectors:
    <ol>
      <li><m>\overrightarrow{N}</m>: The surface normal, a vector perpendicular to the plane of the polygon (or surface), pointing outward.</li>
      <li><m>\overrightarrow{V}</m>: The view vector, a vector pointing out from the plane of the polygon (or surface) into the "eye" of the observer.</li>
    </ol>

    <image source="images/ch06-backface_culling.png">
      <description>A side-view of a polygon with a vctor poining perpendicular from it, and another vector drawn between the surace and an eye.</description>
    </image>

    We can tell if a surface is front or back facing based on the value of <m>\theta</m>, the angle between <m>\overrightarrow{N}</m> and <m>\overrightarrow{V}</m>. When <m> -90 \lt \theta \lt 90</m>, then the surface is visible to the observer. Outside of that range, the surface is pointing away from the observer and is thus a backface. While it is referred to as backface culling, this process could be more accurately described as frontface including. We don't actually remove the backfaces from our polygon lists (if we rotate the shape, then those faces may no longer be back facing!), rather, we check and only draw the polygons facing forward.
  </p>
</section>




Overview of backface culling
1. Calculate $$\overrightarrow{N}$$;
2. Calculate $$\theta$$;
3. IF $$-90 < \theta < 90 $$, draw the triangle.

__Calculate $$\overrightarrow{N}$$__
* We can find the surface normal by taking the cross product of two vectors along the edges of the polygon provided that they share one endpoint and point in opposite directions.
  ![surface normal]({{"/assets/img/n02-surface_normal.png" | relative_url}})
* In the above diagram, $$\overrightarrow{A}$$ is the vector from P0 to P1 and $$\overrightarrow{B}$$; is the vector from P0 to P2

  $$\begin{aligned}
  \overrightarrow{A} &= P_1 - P_0 = <x_1 - x_0, y_1 - y_0, z_1 - z_0> \\
  \overrightarrow{B} &= P_2 - P_0 = <x_2 - x_0, y_2 - y_0, z_2 - z_0> \\
  \overrightarrow{N} &= \overrightarrow{A} \times \overrightarrow{B} \\
  \overrightarrow{N} &= <a_yb_z - a_zb_y, a_zb_x - a_xb_z, a_xb_y - a_yb_x>
  \end{aligned}
  $$

__Calculate &theta;__
  * Before we figure out $$\theta$$, we need to discuss the _view vector_ ($$\overrightarrow{V}$$)
    * $$\overrightarrow{V}$$ is supposed to be a vector that comes out of the plane of the surface and into the observer. So the question is, what is the relationship between the observer and the surface?
      * For right now, we will assume that the observer is very very very far away from the object. This assumption means that moving left, right, up or down will not have any perceptible effect on what part of the object you are looking at.
      * Think about looking up at the moon, if you move around, you don't start to see a new part of the moon. It looks the same, even if you went from Staten Island up to the Bronx, the moon would look the same.
    * This means that we can ignore any changes along the x or y axes, but what about z?
    * z is the important one, since that determines if you are in front of or behind the object. Remember that z moves in a positive direction out from the screen towards the viewer, so $$\overrightarrow{V}$$, the vector from the object to the viewer, should have a positive z component.
    * For right now $$\overrightarrow{V} = <0, 0, 1>$$
      * We don't care about changes in x and y, so leaving them at 0 is fine.
      * We need a positive z.
      * By giving z the value of 1, the total mangnitude of $$\overrightarrow{V}$$ is 1. This is referred to as a _normalized_ vector. It's not very important right now, but it will be later on, so we might as well start here.
      * We will not be looking at changing $$\overrightarrow{V}$$ for now, but you can think about what that would mean for the rendered image and what effects that might lead to.
  * Now that we know both $$\overrightarrow{N}$$ and $$\overrightarrow{V}$$, there's a little bit of vector math we can use to our advantage.
    * Dot product to the rescue: $$\overrightarrow{N} \cdot \overrightarrow{V} = Mcos\theta$$
      * The _[dot product](https://www.mathsisfun.com/algebra/vectors-dot-product.html){:target="_blank"}_ of  $$\overrightarrow{N}$$ and $$\overrightarrow{V}$$ is a _scalar_ (not a vector) value equal to the cosine of the angle between them times the product of each vector's magnitude ($$M$$). You can calculate the dot product like so:
        * $$\overrightarrow{N} \cdot \overrightarrow{V} = Mcos\theta = n_xv_x + n_yv_y + n_zv_z$$
      * If we think about the properties of $$cos\theta$$, this is incredibly useful.
      * $$cos\theta > 0$$ when $$-90 < \theta < 90$$
        * This is exactly what we want.
      * Turns out, we only care about whether or not the dot product is positive or negative. If it's positive, then the triangle is front facing, and we should draw it, if it's negative, we pass. And since mangnitude is always positive, we don't actually need to worry about it for this calculation.
        * (later on, when we get to lighting, we will care about mangnitude, but that's a problem for future us, who will be smarter than present us)

__Putting it all together__
* Given any triangle starting at P0:
  * Calculate $$\overrightarrow{N} = \overrightarrow{A} \times \overrightarrow{B}$$, where $$\overrightarrow{A} = P_1 - P_0$$, and $$\overrightarrow{B} = P_2 - P_0$$.
  * Calculate $$\overrightarrow{N} \cdot \overrightarrow{V}$$, where $$\overrightarrow{V} = <0, 0, 1>$$
  * If $$\overrightarrow{N} \cdot \overrightarrow{V} > 0$$, draw the triangle.
    * The keen observer will note that since $$\overrightarrow{V} = <0, 0, 1>$$, the x and y components of the dot product will be 0. Also, since the z component of $$\overrightarrow{V}$$ is 1, the dot product will simply be the z component of $$\overrightarrow{N}$$.
    * This is ok for now, but eventually we will actually need the value of the dot product, so it doesn't hurt to do that now anyway.
-->
